/**
 * Trade Execution Module
 *
 * This module handles the execution of trade instructions using Uniswap V3.
 * It takes trade instructions generated by the strategy module and executes them
 * on-chain using the Uniswap Router.
 */
import { getTokenPrice } from "./la-token-price";
import { type TradeInstruction } from "../la-strategies/la-instructions";
import { TOKEN_LIST } from "../utils/la-token-list";
import { LitSigner } from "../utils/la-utils";

export type DefaultTradeConfig = {
  // slippage tolerance in basis points
  // default slippage (0.05%)
  SLIPPAGE_BPS: number;

  // maximum allowed slippage (5%)
  MAX_SLIPPAGE_BPS: number;

  // skip small trades
  // trades below this threshold are skipped to avoid excessive gas costs for negligible returns.
  MINIMUM_TRADE_USD: number;

  // the standard fee charged by Uniswap for executing swaps.
  // used to compensate liquidity providers and sustain the Uniswap protocol
  // https://docs.uniswap.org/contracts/v2/concepts/advanced-topics/fees#liquidity-provider-fees
  UNISWAP_FEE: number;

  // the maximum allowable price impact for a trade before execution is blocked.
  // set to 0.02 (2%), meaning a trade will not execute if it causes a price impact above 2%.
  // protects against executing trades that significantly affect market prices.
  MAXIMUM_PRICE_IMPACT: number;

  // set to 1.5 (i.e., 50% buffer) to accommodate potential spikes in gas costs.
  // ensures transactions have sufficient gas even during congestion.
  GAS_COST_BUFFER: number;

  // base gas units for a swap
  // estimated gas units required to execute a standard token swap.
  // covers standard execution logic, including interactions with Uniswap smart contracts.
  // used as a starting point before applying dynamic adjustments.
  GAS_ESTIMATE_BASE: number;

  // additional gas for token approvals
  GAS_ESTIMATE_APPROVE: number;
};

export type GasDataObject = {
  gasPrice: any;
  chainId: any;
  nonce: any;
  maxFeePerGas: any;
  maxPriorityFeePerGas: any;
  estimatedGasCost: any;
};

export type ConfirmationConfig = {
  confirmAll: boolean;
};

// Uniswap Router ABI (only the functions we need)
const UNISWAP_ROUTER_ABI = [
  "function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)",
  "function multicall(bytes[] data) external payable returns (bytes[] results)",
];

export interface ExecutedTrade {
  instruction: TradeInstruction;
  signedSwapTx: string;
  actualAmountOut: string;
  status: "success" | "failed";
  error?: string;
  txs: string[];
}

/**
 * Estimates gas needed for the trade based on operation type
 *
 * @param fromToken - Token being sold
 * @param needsApproval - Whether token approval is needed
 * @returns Estimated gas units with buffer
 */
function estimateGasUnits(
  tradeConfig: DefaultTradeConfig,
  fromToken: string,
  needsApproval: boolean = true
): number {
  let estimate = tradeConfig.GAS_ESTIMATE_BASE;

  // Add gas for approval if needed
  if (fromToken !== "ETH" && needsApproval) {
    estimate += tradeConfig.GAS_ESTIMATE_APPROVE;
  }

  // Apply buffer for safety
  return Math.ceil(estimate * tradeConfig.GAS_COST_BUFFER);
}

/**
 * Estimates the total cost of a trade including gas and protocol fees
 *
 * @param tradeValueUSD - USD value of the trade
 * @param gasPrice - Current gas price in wei
 * @param fromToken - Token being sold
 * @param needsApproval - Whether token approval is needed
 * @returns Total estimated cost in USD
 */
async function estimateTradingCost(
  tradeConfig: DefaultTradeConfig,
  tradeValueUSD: number,
  gasPrice: any,
  fromToken: string,
  needsApproval: boolean = true
): Promise<number> {
  const estimatedGas = estimateGasUnits(tradeConfig, fromToken, needsApproval);
  const gasCostETH = gasPrice.mul(estimatedGas);

  // Get ETH price in USD
  const ethPrice = await getTokenPrice({
    chain: "optimism",
    fromToken: "ETH",
    toToken: "USDC",
    amount: "1.0",
  });

  const gasCostUSD =
    parseFloat(ethPrice) * parseFloat(ethers.utils.formatEther(gasCostETH));
  const protocolFeeUSD = tradeValueUSD * tradeConfig.UNISWAP_FEE;

  return gasCostUSD + protocolFeeUSD;
}

/**
 * Validates if a trade meets minimum requirements and is cost-effective
 *
 * @param instruction - Trade instruction to validate
 * @param gasPrice - Current gas price
 * @param needsApproval - Whether token approval is needed
 * @returns true if valid, throws error if invalid
 */
async function validateTradeEfficiency(
  tradeConfig: DefaultTradeConfig,
  instruction: TradeInstruction,
  gasPrice: any,
  needsApproval: boolean = true
): Promise<boolean> {
  const { fromToken, fromAmount } = instruction;

  const tradeValueUSD = parseFloat(
    await getTokenPrice({
      chain: instruction.chain as keyof typeof TOKEN_LIST,
      fromToken: instruction.fromToken as any,
      toToken: "USDC" as any,
      amount: fromAmount,
    })
  );

  if (tradeValueUSD < tradeConfig.MINIMUM_TRADE_USD) {
    throw new Error(
      "Trade value (" +
        tradeValueUSD.toFixed(2) +
        " USD) below minimum threshold of " +
        tradeConfig.MINIMUM_TRADE_USD +
        " USD"
    );
  }

  const estimatedCost = await estimateTradingCost(
    tradeConfig,
    tradeValueUSD,
    gasPrice,
    fromToken,
    needsApproval
  );
  const costPercentage = (estimatedCost / tradeValueUSD) * 100;

  console.log(
    "Trade Cost Analysis:\\n" +
      "    Trade Value: $" +
      tradeValueUSD.toFixed(2) +
      "\\n" +
      "    Estimated Costs: $" +
      estimatedCost.toFixed(2) +
      " (" +
      costPercentage.toFixed(2) +
      "%)\\n" +
      "    Gas Units: " +
      estimateGasUnits(tradeConfig, fromToken, needsApproval).toLocaleString() +
      "\\n" +
      "    Gas Price: " +
      ethers.utils.formatUnits(gasPrice, "gwei") +
      " gwei"
  );

  if (costPercentage > 5) {
    throw new Error(
      "Trading costs (" +
        costPercentage.toFixed(2) +
        "%) too high relative to trade value"
    );
  }

  return true;
}

/**
 * Validates trade parameters and ensures they meet minimum requirements
 *
 * @param instruction - Trade instruction to validate
 * @param chainConfig - Chain configuration from token list
 * @returns true if valid, throws error if invalid
 */
async function validateTrade(
  instruction: TradeInstruction,
  chainConfig: (typeof TOKEN_LIST)[keyof typeof TOKEN_LIST]
): Promise<boolean> {
  const { fromToken, toToken, fromAmount } = instruction;

  const fromTokenConfig =
    chainConfig.tokens[fromToken as keyof typeof chainConfig.tokens];
  const toTokenConfig =
    chainConfig.tokens[toToken as keyof typeof chainConfig.tokens];

  if (!fromTokenConfig || !toTokenConfig) {
    throw new Error(
      "Invalid token configuration for " + fromToken + " or " + toToken
    );
  }

  const parsedAmount = parseFloat(fromAmount);
  if (isNaN(parsedAmount) || parsedAmount <= 0) {
    throw new Error("Invalid trade amount: " + fromAmount);
  }

  return true;
}

export async function generateGasDataObjects(params: {
  instructions: TradeInstruction[];
  signerInfo: {
    address: string;
    pkpPubkey: string;
  };
  tradeConfig: DefaultTradeConfig;
  confirmationConfig: ConfirmationConfig;
}): Promise<GasDataObject[]> {
  const { tradeConfig, instructions, confirmationConfig, signerInfo } = params;

  const gasDataObjs: GasDataObject[] = [];

  for (const instruction of instructions) {
    const litProviderRpcUrl = await Lit.Actions.getRpcUrl({
      chain: instruction.chain,
    });

    const provider = new ethers.providers.JsonRpcProvider(litProviderRpcUrl);

    console.log("--- start run once ---");
    let gasData: any = await Lit.Actions.runOnce(
      {
        waitForResponse: true,
        name: "getGasPrice",
      },
      async () => {
        const errors: string[] = [];
        let baseFeeHistory;
        let baseFee;
        let priorityFee;
        let maxFee;
        let gasPrice;
        // let estimatedGasCost;
        // let nonce;

        try {
          baseFeeHistory = await provider.send("eth_feeHistory", [
            "0x1",
            "latest",
            [],
          ]);
        } catch (error: any) {
          errors.push(
            "Failed to get base fee history: " +
              (error?.message || "Unknown error")
          );
          baseFeeHistory = { baseFeePerGas: ["0x0"] };
        }

        try {
          gasPrice = await provider.getGasPrice();
        } catch (error: any) {
          errors.push(
            "Failed to get gas price: " + (error?.message || "Unknown error")
          );
          gasPrice = ethers.BigNumber.from("0");
        }

        try {
          baseFee = ethers.BigNumber.from(baseFeeHistory.baseFeePerGas[0]);
          priorityFee = baseFee.div(4);
          maxFee = baseFee.mul(2);
        } catch (error: any) {
          errors.push(
            "Failed to calculate fees: " + (error?.message || "Unknown error")
          );
          baseFee = ethers.BigNumber.from("0");
          priorityFee = ethers.BigNumber.from("0");
          maxFee = ethers.BigNumber.from("0");
        }

        // try {
        //   estimatedGasCost = gasPrice.mul(tradeConfig.GAS_ESTIMATE_BASE);
        // } catch (error: any) {
        //   errors.push(
        //     "Failed to calculate estimated gas cost: " +
        //       (error?.message || "Unknown error")
        //   );
        //   estimatedGasCost = ethers.BigNumber.from("0");
        // }

        // try {
        //   nonce = await provider.getTransactionCount(signerInfo.address);
        // } catch (error: any) {
        //   errors.push(
        //     "Failed to get nonce: " + (error?.message || "Unknown error")
        //   );
        //   nonce = 0;
        // }

        return JSON.stringify({
          gasPrice: gasPrice.toHexString(),
          chainId:
            TOKEN_LIST[instruction.chain as keyof typeof TOKEN_LIST].chainId,
          // nonce: nonce.toString(),
          maxFeePerGas: maxFee.toHexString(),
          maxPriorityFeePerGas: priorityFee.toHexString(),
          // estimatedGasCost: estimatedGasCost.toHexString(),
          errors,
        });
      }
    );
    console.log("--- end run once ---");

    gasDataObjs.push(gasData);
  }

  return gasDataObjs;
}

/**
 * Executes a batch of trade instructions
 *
 * @param instructions - Array of trade instructions to execute
 * @param slippageBps - Slippage tolerance in basis points
 * @returns Array of execution results
 */
export async function executeTradeInstructions(params: {
  instructions: TradeInstruction[];
  gasDataObjs: GasDataObject[];
  signerInfo: {
    address: string;
    pkpPubkey: string;
  };
  tradeConfig: DefaultTradeConfig;
  confirmationConfig: ConfirmationConfig;
}): Promise<ExecutedTrade[]> {
  const { tradeConfig, instructions, confirmationConfig, signerInfo } = params;
  const results: ExecutedTrade[] = [];

  let nonceCounter = 0;

  for (let i = 0; i < instructions.length; i++) {
    const instruction = instructions[i];
    const gasDataObj = JSON.parse(gasDataObjs[i] as any) as GasDataObject;
    console.log("gasDataObj:", gasDataObj);

    // Convert hex strings to BigNumber for gas-related fields
    gasDataObj.gasPrice = ethers.BigNumber.from(gasDataObj.gasPrice); // 0x0f484f
    gasDataObj.chainId = Number(gasDataObj.chainId); // Keep as number 10
    // gasDataObj.nonce = Number(gasDataObj.nonce); // Keep as string "19"
    gasDataObj.maxFeePerGas = ethers.BigNumber.from(gasDataObj.maxFeePerGas); // 0x0c1e
    gasDataObj.maxPriorityFeePerGas = ethers.BigNumber.from(
      gasDataObj.maxPriorityFeePerGas
    ); // 0x0183
    // gasDataObj.estimatedGasCost = ethers.BigNumber.from(
    //   gasDataObj.estimatedGasCost
    // ); // 0x45f520a220
    console.log("gasDataObj 2:", gasDataObj);

    const litProviderRpcUrl = await Lit.Actions.getRpcUrl({
      chain: instruction.chain,
    });

    const provider = new ethers.providers.JsonRpcProvider(litProviderRpcUrl);
    const chainConfig =
      TOKEN_LIST[instruction.chain as keyof typeof TOKEN_LIST];

    const fromTokenConfig =
      chainConfig.tokens[
        instruction.fromToken as keyof typeof chainConfig.tokens
      ];

    const toTokenConfig =
      chainConfig.tokens[
        instruction.toToken as keyof typeof chainConfig.tokens
      ];

    const amountIn = ethers.utils.parseUnits(
      instruction.fromAmount,
      fromTokenConfig.decimals || 18
    );

    console.log("---------- get approve tx ---------");
    const APPROVE_ABI = [
      "function approve(address spender, uint256 amount) external returns (bool)",
    ];
    const tokenInterface = new ethers.utils.Interface(APPROVE_ABI);

    const txData = tokenInterface.encodeFunctionData("approve", [
      chainConfig.uniswap.swapRouter02,
      amountIn.mul(110).div(100), // Add 10% safety margin to approval amount
    ]);
    const nonce = await provider.getTransactionCount(signerInfo.address);
    console.log("txData:", txData);

    // console.log(ethers.BigNumber.from("300000"));
    // console.log(gasDataObj.estimatedGasCost);

    const approveTx = {
      to: fromTokenConfig.address,
      data: txData,
      value: "0x0",
      gasLimit: ethers.BigNumber.from(tradeConfig.GAS_ESTIMATE_BASE),
      maxFeePerGas: gasDataObj.maxFeePerGas.mul(1000).div(100),
      maxPriorityFeePerGas: gasDataObj.maxPriorityFeePerGas.mul(1000).div(100),
      nonce: nonce + nonceCounter,
      chainId: gasDataObj.chainId,
      type: 2,
    };

    console.log("approveTx:", approveTx);

    console.log("---------- sign approve tx ---------");
    const signedApproveTx = await LitSigner.signTx({
      tx: approveTx,
      sigName: "approveSig",
      pkpPubkey: signerInfo.pkpPubkey,
    });

    console.log("signedApproveTx:", signedApproveTx);

    const approveTxHash = await LitSigner.sendTx(signedApproveTx, provider);
    nonceCounter++;

    console.log("approveTxHash:", approveTxHash);

    console.log("---------- get swap tx ---------");
    const SWAP_ROUTER_ABI = [
      "function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)",
    ];

    const routerInterface = new ethers.utils.Interface(SWAP_ROUTER_ABI);

    const swapTxData = routerInterface.encodeFunctionData("exactInputSingle", [
      [
        fromTokenConfig.address,
        toTokenConfig.address,
        chainConfig.uniswap.fee,
        signerInfo.address,
        Math.floor(Date.now() / 1000) + 300, // 5 minutes deadline
        amountIn,
        instruction.minAmountOut,
        0, // sqrtPriceLimitX96
      ],
    ]);

    console.log("swapTxData:", swapTxData);

    const swapTx = {
      to: chainConfig.uniswap.swapRouter02,
      data: swapTxData,
      value: "0x0",
      gasLimit: ethers.BigNumber.from(tradeConfig.GAS_ESTIMATE_BASE).mul(2), // Double the gas limit
      maxFeePerGas: gasDataObj.maxFeePerGas.mul(1000).div(100),
      maxPriorityFeePerGas: gasDataObj.maxPriorityFeePerGas.mul(1000).div(100),
      nonce: nonce + nonceCounter,
      chainId: gasDataObj.chainId,
      type: 2,
    };

    // Add price impact check
    const quoterContract = new ethers.Contract(
      chainConfig.uniswap.quoter,
      [
        "function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)",
      ],
      provider
    );

    try {
      const quote = await quoterContract.callStatic.quoteExactInputSingle(
        fromTokenConfig.address,
        toTokenConfig.address,
        chainConfig.uniswap.fee,
        amountIn,
        0
      );

      // Calculate minimum output based on the actual quote and slippage
      const minAmountOut = quote
        .mul(ethers.BigNumber.from(10000).sub(tradeConfig.SLIPPAGE_BPS))
        .div(10000);

      // Update the swap data with the new minimum output
      const updatedSwapTxData = routerInterface.encodeFunctionData(
        "exactInputSingle",
        [
          [
            fromTokenConfig.address,
            toTokenConfig.address,
            chainConfig.uniswap.fee,
            signerInfo.address,
            Math.floor(Date.now() / 1000) + 300, // 5 minutes deadline
            amountIn,
            minAmountOut,
            0, // sqrtPriceLimitX96
          ],
        ]
      );

      swapTx.data = updatedSwapTxData;

      // Get the spot price for comparison (1 unit of input token)
      const spotQuote = await quoterContract.callStatic.quoteExactInputSingle(
        fromTokenConfig.address,
        toTokenConfig.address,
        chainConfig.uniswap.fee,
        ethers.utils.parseUnits("1", fromTokenConfig.decimals || 18),
        0
      );

      // Calculate actual price impact by comparing trade price to spot price
      const actualPrice = quote
        .mul(ethers.utils.parseUnits("1", fromTokenConfig.decimals || 18))
        .div(amountIn);
      const priceImpact =
        spotQuote.sub(actualPrice).mul(10000).div(spotQuote).toNumber() / 100;
      console.log("Price Impact:", priceImpact.toString() + "%");

      if (priceImpact > tradeConfig.MAXIMUM_PRICE_IMPACT) {
        throw new Error(
          "Price impact too high: " + priceImpact.toString() + "%"
        );
      }
    } catch (error: any) {
      console.error("Price impact check failed:", error);
      throw error;
    }

    console.log("swapTx:", swapTx);

    console.log("---------- sign swap tx ---------");
    const signedSwapTx = await LitSigner.signTx({
      tx: swapTx,
      sigName: "swapSig",
      pkpPubkey: signerInfo.pkpPubkey,
    });
    console.log("signedSwapTx:", signedSwapTx);

    console.log("---------- send swap tx ---------");
    const swapTxHash = await LitSigner.sendTx(signedSwapTx, provider);
    nonceCounter++;
    console.log("swapTxHash:", swapTxHash);

    const isSuccess = typeof swapTxHash === "string";
    const error =
      !isSuccess && typeof swapTxHash === "object"
        ? swapTxHash.error
        : undefined;

    results.push({
      instruction,
      signedSwapTx,
      actualAmountOut: "0", // We'll need to get this from the receipt
      status: isSuccess ? "success" : "failed",
      error,

      // @ts-ignore
      txs: [approveTxHash, swapTxHash].filter((tx): tx is string => {
        if (typeof tx === "string") return true;
        if (typeof tx === "object" && tx !== null) return false;
        return false;
      }),
    });
  }

  return results;
}

// Example usage:
// async function main() {
//   try {
//     // Generate trade instructions
//     const instructions = await generateRebalanceInstructions(env.ETH_ADDRESS);

//     if (instructions.length === 0) {
//       console.log("No rebalancing needed");
//       return;
//     }

//     // Ask for slippage configuration
//     const answers = await inquirer.prompt([
//       {
//         type: "number",
//         name: "slippageBps",
//         message: "Enter slippage tolerance in basis points (e.g., 5 = 0.05%):",
//         default: DEFAULT_SLIPPAGE_BPS,
//       },
//     ]);

//     const slippageBps = Math.max(
//       1,
//       Math.min(MAX_SLIPPAGE_BPS, answers.slippageBps || DEFAULT_SLIPPAGE_BPS)
//     );

//     // Execute trades
//     console.log(`\nExecuting ${instructions.length} trades...`);
//     const results = await executeTradeInstructions(instructions, slippageBps);

//     // Log results
//     console.log("\nExecution Results:");
//     for (const result of results) {
//       if (result.status === "success") {
//         console.log(
//           `✅ ${result.instruction.fromToken} -> ${result.instruction.toToken}`
//         );
//         console.log(
//           `   Amount: ${result.instruction.fromAmount} -> ${result.actualAmountOut}`
//         );
//         console.log(`   Tx: ${result.transactionHash}`);
//       } else {
//         console.log(
//           `❌ ${result.instruction.fromToken} -> ${result.instruction.toToken}`
//         );
//         console.log(`   Error: ${result.error}`);
//       }
//     }
//   } catch (error) {
//     console.error("Error:", error);
//   }

//   const portfolio = await getPortfolio(env.ETH_ADDRESS);
//   console.log(portfolio);
// }

// main();
